{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "d80e6cf3-c7c2-4f8a-a02e-43307616acd6",
   "metadata": {},
   "outputs": [],
   "source": [
    "import cv2\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import time\n",
    "import matplotlib.pyplot as plt\n",
    "import csv\n",
    "from collections import deque\n",
    "from pathlib import Path\n",
    "\n",
    "%matplotlib notebook\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "424793e6-161f-44e7-bb6b-5bd3c218d880",
   "metadata": {},
   "source": [
    "### Region of Interest (ROI) Selector\n",
    "\n",
    "Grabs a frame and opens an interactive window.\n",
    "\n",
    "Click and drag a box then press return."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "891dfda1-2005-44ae-96b5-5c11fcd260ea",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ROI: (21, 82, 42, 37)\n"
     ]
    }
   ],
   "source": [
    "def pick_roi_opencv(cam=0):\n",
    "    \"\"\"\n",
    "    Open the specified camera, grab a single frame, and allow the user\n",
    "    to select a rectangular ROI (Region of Interest) interactively\n",
    "    using OpenCV's ROI selector window.\n",
    "\n",
    "    Controls:\n",
    "        - Drag with the mouse to define the ROI box\n",
    "        - Press ENTER or SPACE to confirm\n",
    "        - Press C or ESC to cancel\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    cam : int, optional\n",
    "        Camera index (0 = default webcam). Defaults to 0.\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    tuple\n",
    "        (roi, frame)\n",
    "        roi : tuple of int\n",
    "            (x, y, w, h) coordinates of the selected ROI\n",
    "        frame : numpy.ndarray\n",
    "            The captured frame (BGR image) from which the ROI was selected\n",
    "\n",
    "    Raises\n",
    "    ------\n",
    "    RuntimeError\n",
    "        If no frame can be captured from the camera.\n",
    "    ValueError\n",
    "        If the ROI width or height is zero (no valid selection).\n",
    "    \"\"\"\n",
    "    cap = cv2.VideoCapture(cam)\n",
    "    ok, frame = cap.read()\n",
    "    cap.release()\n",
    "    if not ok:\n",
    "        raise RuntimeError(\"Could not read a frame from camera.\")\n",
    "\n",
    "    # Mirror frame as video feed to be mirrored\n",
    "    frame = cv2.flip(frame, 1)\n",
    "    \n",
    "    # Drag to select; press ENTER/SPACE to accept, or C/ESC to cancel\n",
    "    r = cv2.selectROI(\"Select ROI\", frame, fromCenter=False, showCrosshair=True)\n",
    "    cv2.destroyWindow(\"Select ROI\")\n",
    "\n",
    "    x, y, w, h = map(int, r)\n",
    "    if w == 0 or h == 0:\n",
    "        raise ValueError(\"Empty ROI selected.\")\n",
    "    return (x, y, w, h), frame\n",
    "\n",
    "\n",
    "# Example usage\n",
    "roi, frame = pick_roi_opencv(0)\n",
    "print(\"ROI:\", roi)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9c8a6a6e-c993-4029-84b5-4166329129ce",
   "metadata": {},
   "source": [
    "### Video Capture\n",
    "\n",
    "Live video capture in new window. No trace."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "18be7d0e-b285-4500-b6b9-7486de25a563",
   "metadata": {},
   "outputs": [],
   "source": [
    "def pick_roi_opencv(cam=0):\n",
    "    \"\"\"\n",
    "    Open the camera, grab one frame, and let the user select an ROI.\n",
    "    Returns (roi, frame) where roi=(x,y,w,h) and frame is the BGR image.\n",
    "    \"\"\"\n",
    "    cap = cv2.VideoCapture(cam)\n",
    "    ok, frame = cap.read()\n",
    "    cap.release()\n",
    "    if not ok:\n",
    "        raise RuntimeError(\"Could not read a frame from camera.\")\n",
    "    r = cv2.selectROI(\"Select ROI\", frame, fromCenter=False, showCrosshair=True)\n",
    "    cv2.destroyWindow(\"Select ROI\")\n",
    "    x, y, w, h = map(int, r)\n",
    "    if w == 0 or h == 0:\n",
    "        raise ValueError(\"Empty ROI selected.\")\n",
    "    return (x, y, w, h), frame\n",
    "\n",
    "def render_plot_image(tbuf, rbuf, gbuf, bbuf, height=480, width=480, margin=30):\n",
    "    \"\"\"\n",
    "    Render a simple RGB-vs-time plot into an RGB image (uses OpenCV primitives).\n",
    "    \"\"\"\n",
    "    img = np.ones((height, width, 3), np.uint8) * 20\n",
    "    x0, y0 = margin, margin\n",
    "    x1, y1 = width - margin, height - margin\n",
    "    cv2.rectangle(img, (x0, y0), (x1, y1), (80, 80, 80), 1)\n",
    "\n",
    "    if len(tbuf) >= 2:\n",
    "        tmin, tmax = tbuf[0], tbuf[-1]\n",
    "        ymin = float(min(min(rbuf), min(gbuf), min(bbuf)))\n",
    "        ymax = float(max(max(rbuf), max(gbuf), max(bbuf)))\n",
    "        if ymin == ymax:\n",
    "            pad = 0.01 if ymax <= 1.0 else 1.0\n",
    "            ymin -= pad; ymax += pad\n",
    "\n",
    "        def to_px(t, y):\n",
    "            xx = int(x0 + (t - tmin) / (tmax - tmin + 1e-9) * (x1 - x0))\n",
    "            yy = int(y1 - (y - ymin) / (ymax - ymin + 1e-12) * (y1 - y0))\n",
    "            return xx, yy\n",
    "\n",
    "        for series, color in ((rbuf, (60, 60, 220)),\n",
    "                              (gbuf, (60, 220, 60)),\n",
    "                              (bbuf, (220, 60, 60))):\n",
    "            pts = [to_px(t, y) for t, y in zip(tbuf, series)]\n",
    "            for p, q in zip(pts[:-1], pts[1:]):\n",
    "                cv2.line(img, p, q, color, 2, lineType=cv2.LINE_AA)\n",
    "\n",
    "        cv2.putText(img, f\"{tmin:0.1f}s\", (x0, y1 + 22), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (160,160,160), 1)\n",
    "        cv2.putText(img, f\"{tmax:0.1f}s\", (x1 - 55, y1 + 22), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (160,160,160), 1)\n",
    "        cv2.putText(img, f\"{ymax:.3f}\", (5, y0 + 5), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (160,160,160), 1)\n",
    "        cv2.putText(img, f\"{ymin:.3f}\", (5, y1),      cv2.FONT_HERSHEY_SIMPLEX, 0.5, (160,160,160), 1)\n",
    "\n",
    "    cv2.putText(img, \"R\", (x0+5,  y0+20), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (60, 60, 220), 2)\n",
    "    cv2.putText(img, \"G\", (x0+35, y0+20), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (60, 220, 60), 2)\n",
    "    cv2.putText(img, \"B\", (x0+65, y0+20), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (220, 60, 60), 2)\n",
    "    return img\n",
    "\n",
    "def live_rgb_side_by_side(\n",
    "    cam=0,\n",
    "    roi=None,\n",
    "    csv_path=\"rgb_trace.csv\",\n",
    "    downsample=1,\n",
    "    to_float=True,\n",
    "    plot_window_sec=30,\n",
    "    output_height=600,\n",
    "    save_raw=False,\n",
    "    raw_video_path=\"raw_feed.avi\",\n",
    "    raw_codec=\"XVID\"  # use \"mp4v\" with .mp4 if you prefer\n",
    "):\n",
    "    \"\"\"\n",
    "    Live capture + side-by-side display (video + rolling RGB plot), CSV logging,\n",
    "    and optional raw video recording (no overlays, no mirroring).\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    cam : int\n",
    "        Camera index.\n",
    "    roi : (x, y, w, h) or None\n",
    "        ROI rectangle. If None, an OpenCV ROI picker opens first.\n",
    "    csv_path : str\n",
    "        CSV file path for mean RGB samples.\n",
    "    downsample : int\n",
    "        Process one out of every N frames (1 = process all).\n",
    "    to_float : bool\n",
    "        If True, RGB in [0,1]; else [0,255].\n",
    "    plot_window_sec : int\n",
    "        Rolling window length shown in the plot (seconds). 0/None = unbounded.\n",
    "    output_height : int\n",
    "        Composite window height (video and plot are scaled to this).\n",
    "    save_raw : bool\n",
    "        If True, write the **raw camera frames** to `raw_video_path`.\n",
    "        (No overlays, no plot, no mirroring; useful for post hoc reprocessing.)\n",
    "    raw_video_path : str\n",
    "        Output path for the raw recording.\n",
    "    raw_codec : str\n",
    "        FourCC codec for the raw recording (e.g. \"XVID\", \"MJPG\", \"mp4v\").\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    dict with keys: csv, roi, downsample, raw_video_path (if saving)\n",
    "    \"\"\"\n",
    "    if roi is None:\n",
    "        roi, _ = pick_roi_opencv(cam)\n",
    "    x, y, w, h = roi\n",
    "\n",
    "    cap = cv2.VideoCapture(cam)\n",
    "    if not cap.isOpened():\n",
    "        raise IOError(f\"Cannot open camera {cam}\")\n",
    "\n",
    "    # CSV init\n",
    "    csv_path = Path(csv_path)\n",
    "    new_file = not csv_path.exists()\n",
    "    f = open(csv_path, \"a\", newline=\"\")\n",
    "    writer = csv.writer(f)\n",
    "    if new_file:\n",
    "        writer.writerow([\"t_sec\", \"R\", \"G\", \"B\", \"x\", \"y\", \"w\", \"h\"])\n",
    "\n",
    "    # Raw recorder init (exact camera frames)\n",
    "    out_raw = None\n",
    "    if save_raw:\n",
    "        fourcc = cv2.VideoWriter_fourcc(*raw_codec)\n",
    "        fps = cap.get(cv2.CAP_PROP_FPS) or 30.0\n",
    "        frame_size = (int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)),\n",
    "                      int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))\n",
    "        out_raw = cv2.VideoWriter(raw_video_path, fourcc, fps, frame_size)\n",
    "\n",
    "    # Buffers for plot\n",
    "    tbuf, rbuf, gbuf, bbuf = deque(), deque(), deque(), deque()\n",
    "\n",
    "    start = time.perf_counter()\n",
    "    frame_idx = 0\n",
    "    last_flush = start\n",
    "    window_name = \"Live RGB (press q to stop)\"\n",
    "\n",
    "    try:\n",
    "        while True:\n",
    "            ok, frame_bgr = cap.read()\n",
    "            if not ok:\n",
    "                break\n",
    "\n",
    "            # Always write the raw frame BEFORE any drawing/mirroring/etc.\n",
    "            if out_raw is not None:\n",
    "                out_raw.write(frame_bgr)\n",
    "\n",
    "            if frame_idx % downsample == 0:\n",
    "                t = time.perf_counter() - start\n",
    "\n",
    "                H, W = frame_bgr.shape[:2]\n",
    "                x0 = max(0, min(x, W - 1))\n",
    "                y0 = max(0, min(y, H - 1))\n",
    "                w0 = max(1, min(w, W - x0))\n",
    "                h0 = max(1, min(h, H - y0))\n",
    "\n",
    "                roi_img = frame_bgr[y0:y0+h0, x0:x0+w0]\n",
    "                mean_bgr = roi_img.mean(axis=(0, 1))\n",
    "                mean_rgb = mean_bgr[::-1]\n",
    "                if to_float:\n",
    "                    mean_rgb = mean_rgb / 255.0\n",
    "                R, G, B = map(float, mean_rgb)\n",
    "\n",
    "                # CSV logging\n",
    "                writer.writerow([t, R, G, B, x0, y0, w0, h0])\n",
    "\n",
    "                # Update plot buffers\n",
    "                tbuf.append(t); rbuf.append(R); gbuf.append(G); bbuf.append(B)\n",
    "                while plot_window_sec and tbuf and (t - tbuf[0] > plot_window_sec):\n",
    "                    tbuf.popleft(); rbuf.popleft(); gbuf.popleft(); bbuf.popleft()\n",
    "\n",
    "                # Left panel: live video with overlay (for viewing only)\n",
    "                view = cv2.flip(frame_bgr, 1)\n",
    "                cv2.rectangle(view, (x0, y0), (x0+w0, y0+h0), (0, 255, 0), 2)\n",
    "                cv2.putText(view, f\"R={R:.3f} G={G:.3f} B={B:.3f}\", (10, 30),\n",
    "                            cv2.FONT_HERSHEY_SIMPLEX, 0.7, (50,200,50), 2)\n",
    "                cv2.putText(view, f\"t={t:6.2f}s  ROI=({x0},{y0},{w0},{h0})\", (10, 55),\n",
    "                            cv2.FONT_HERSHEY_SIMPLEX, 0.6, (50,200,50), 2)\n",
    "\n",
    "                # Right panel: rolling plot\n",
    "                plot_img = render_plot_image(tbuf, rbuf, gbuf, bbuf,\n",
    "                                             height=view.shape[0], width=view.shape[0])\n",
    "\n",
    "                # Stack side by side at requested height\n",
    "                h_target = output_height\n",
    "                def resize_h(img, h=h_target):\n",
    "                    s = h / img.shape[0]\n",
    "                    return cv2.resize(img, (int(img.shape[1]*s), h), interpolation=cv2.INTER_AREA)\n",
    "\n",
    "                canvas = np.hstack([resize_h(view), resize_h(plot_img)])\n",
    "                cv2.imshow(window_name, canvas)\n",
    "\n",
    "                # Periodic flush\n",
    "                now = time.perf_counter()\n",
    "                if now - last_flush > 2:\n",
    "                    f.flush()\n",
    "                    last_flush = now\n",
    "            else:\n",
    "                # Keep UI responsive even on skipped frames\n",
    "                cv2.imshow(window_name, frame_bgr)\n",
    "\n",
    "            if cv2.waitKey(1) & 0xFF == ord('q'):\n",
    "                break\n",
    "\n",
    "            frame_idx += 1\n",
    "\n",
    "    except KeyboardInterrupt:\n",
    "        pass\n",
    "    finally:\n",
    "        cap.release()\n",
    "        if out_raw is not None:\n",
    "            out_raw.release()\n",
    "        cv2.destroyAllWindows()\n",
    "        f.flush(); f.close()\n",
    "\n",
    "    out = {\"csv\": str(csv_path.resolve()), \"roi\": (x, y, w, h), \"downsample\": downsample}\n",
    "    if save_raw:\n",
    "        out[\"raw_video_path\"] = str(Path(raw_video_path).resolve())\n",
    "    print(\"Saved trace to:\", out[\"csv\"])\n",
    "    if save_raw:\n",
    "        print(\"Saved raw video to:\", out[\"raw_video_path\"])\n",
    "    return out\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "1fc3f11d-6796-4821-8662-ac4ec822b24a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Saved trace to: C:\\Users\\padin_000\\Documents\\github\\camera\\rgb_trace.csv\n",
      "Saved raw video to: C:\\Users\\padin_000\\Documents\\github\\camera\\backup_raw.mp4\n"
     ]
    }
   ],
   "source": [
    "info = live_rgb_side_by_side(cam=0, roi=roi, save_raw = True, raw_video_path=\"backup_raw.mp4\", csv_path=\"rgb_trace.csv\", raw_codec=\"mp4v\", downsample=1, to_float=True, plot_window_sec=30)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e4d88fde-7675-4b4e-8589-90841c99e6ff",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.18"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
